#! /bin/sh /usr/share/dpatch/dpatch-run
## 108_CVE-2008-3655.dpatch by Jamie Strandboge <jamie@ubuntu.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Upstream: svn 1_8_6 r17690 r17694 r17807 r17359 r17702
## DP: Description: CVE-2008-3655

@DPATCH@
diff -urNad ruby1.8-1.8.6.111~/eval.c ruby1.8-1.8.6.111/eval.c
--- ruby1.8-1.8.6.111~/eval.c	2007-09-22 19:01:50.000000000 -0500
+++ ruby1.8-1.8.6.111/eval.c	2008-10-07 15:34:05.000000000 -0500
@@ -5776,8 +5776,7 @@
     TMP_PROTECT;
     volatile int safe = -1;
 
-    if (NOEX_SAFE(flags) > ruby_safe_level &&
-	ruby_safe_level == 0 && NOEX_SAFE(flags) > 2) {
+    if (NOEX_SAFE(flags) > ruby_safe_level && NOEX_SAFE(flags) > 2) {
 	rb_raise(rb_eSecurityError, "calling insecure method: %s",
 		 rb_id2name(id));
     }
@@ -8332,16 +8331,25 @@
  * MISSING: documentation
  */
 
+#define PROC_TSHIFT (FL_USHIFT+1)
+#define PROC_TMASK  (FL_USER1|FL_USER2|FL_USER3)
+#define PROC_TMAX   (PROC_TMASK >> PROC_TSHIFT)
+
+static int proc_get_safe_level(VALUE);
+
 static VALUE
 proc_dup(self)
     VALUE self;
 {
     struct BLOCK *orig, *data;
     VALUE bind;
+    int safe = proc_get_safe_level(self);
 
     Data_Get_Struct(self, struct BLOCK, orig);
     bind = Data_Make_Struct(rb_obj_class(self),struct BLOCK,blk_mark,blk_free,data);
     blk_dup(data, orig);
+    if (safe > PROC_TMAX) safe = PROC_TMAX;
+    FL_SET(bind, (safe << PROC_TSHIFT) & PROC_TMASK);
 
     return bind;
 }
@@ -8403,10 +8411,6 @@
     return bind;
 }
 
-#define PROC_TSHIFT (FL_USHIFT+1)
-#define PROC_TMASK  (FL_USER1|FL_USER2|FL_USER3)
-#define PROC_TMAX   (PROC_TMASK >> PROC_TSHIFT)
-
 #define SAFE_LEVEL_MAX PROC_TMASK
 
 static void
diff -urNad ruby1.8-1.8.6.111~/ext/syslog/syslog.c ruby1.8-1.8.6.111/ext/syslog/syslog.c
--- ruby1.8-1.8.6.111~/ext/syslog/syslog.c	2007-02-12 17:01:19.000000000 -0600
+++ ruby1.8-1.8.6.111/ext/syslog/syslog.c	2008-10-07 15:34:05.000000000 -0500
@@ -22,6 +22,7 @@
 {
     VALUE str;
 
+    rb_secure(4);
     if (argc < 1) {
         rb_raise(rb_eArgError, "no log message supplied");
     }
@@ -38,6 +39,7 @@
 /* Syslog module methods */
 static VALUE mSyslog_close(VALUE self)
 {
+    rb_secure(4);
     if (!syslog_opened) {
         rb_raise(rb_eRuntimeError, "syslog not opened");
     }
@@ -132,6 +134,7 @@
 
 static VALUE mSyslog_set_mask(VALUE self, VALUE mask)
 {
+    rb_secure(4);
     if (!syslog_opened) {
         rb_raise(rb_eRuntimeError, "must open syslog before setting log mask");
     }
diff -urNad ruby1.8-1.8.6.111~/ruby.c ruby1.8-1.8.6.111/ruby.c
--- ruby1.8-1.8.6.111~/ruby.c	2008-10-07 15:34:01.000000000 -0500
+++ ruby1.8-1.8.6.111/ruby.c	2008-10-07 15:34:05.000000000 -0500
@@ -1040,6 +1040,7 @@
     VALUE val;
     ID id;
 {
+    VALUE progname;
     char *s;
     long i;
 #if !defined(PSTAT_SETCMD) && !defined(HAVE_SETPROCTITLE)
@@ -1064,10 +1065,10 @@
 	j.pst_command = s;
 	pstat(PSTAT_SETCMD, j, i, 0, 0);
     }
-    rb_progname = rb_tainted_str_new(s, i);
+    progname = rb_tainted_str_new(s, i);
 #elif defined(HAVE_SETPROCTITLE)
     setproctitle("%.*s", (int)i, s);
-    rb_progname = rb_tainted_str_new(s, i);
+    progname = rb_tainted_str_new(s, i);
 #else
     if (len == 0) {
 	char *s = origargv[0];
@@ -1102,8 +1103,9 @@
     if (++i < len) memset(s + 1, ' ', len - i);
     for (i = 1; i < origargc; i++)
 	origargv[i] = s;
-    rb_progname = rb_tainted_str_new2(origargv[0]);
+    progname = rb_tainted_str_new2(origargv[0]);
 #endif
+    rb_progname = rb_obj_freeze(progname);
 }
 
 void
@@ -1111,7 +1113,7 @@
     const char *name;
 {
     if (name) {
-	rb_progname = rb_tainted_str_new2(name);
+	rb_progname = rb_obj_freeze(rb_tainted_str_new2(name));
 	ruby_sourcefile = rb_source_filename(name);
     }
 }
diff -urNad ruby1.8-1.8.6.111~/variable.c ruby1.8-1.8.6.111/variable.c
--- ruby1.8-1.8.6.111~/variable.c	2007-08-21 18:52:26.000000000 -0500
+++ ruby1.8-1.8.6.111/variable.c	2008-10-07 15:34:05.000000000 -0500
@@ -642,6 +642,7 @@
     struct global_entry *entry;
     struct trace_var *trace;
 
+    rb_secure(4);
     rb_scan_args(argc, argv, "11", &var, &cmd);
     id = rb_to_id(var);
     if (!st_lookup(rb_global_tbl, id, (st_data_t *)&entry)) {

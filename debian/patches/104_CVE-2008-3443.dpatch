#! /bin/sh /usr/share/dpatch/dpatch-run
## 104_CVE-2008-3443.dpatch by Jamie Strandboge <jamie@ubuntu.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Upstream: svn 1_8_6 r18343
## DP: Description: CVE-2008-3443

@DPATCH@
diff -urNad ruby1.8-1.8.6.111~/regex.c ruby1.8-1.8.6.111/regex.c
--- ruby1.8-1.8.6.111~/regex.c	2007-02-27 05:51:55.000000000 -0600
+++ ruby1.8-1.8.6.111/regex.c	2008-10-07 13:59:34.000000000 -0500
@@ -50,6 +50,9 @@
 /* We need this for `regex.h', and perhaps for the Emacs include files.  */
 # include <sys/types.h>
 #endif
+#ifdef HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
 
 #if !defined(__STDC__) && !defined(_MSC_VER)
 # define volatile
@@ -63,6 +66,10 @@
 
 #ifdef RUBY_PLATFORM
 #include "defines.h"
+#undef xmalloc
+#undef xrealloc
+#undef xcalloc
+#undef xfree
 
 # define RUBY
 extern int rb_prohibit_interrupt;
@@ -104,6 +111,11 @@
 # include <strings.h>
 #endif
 
+#define xmalloc     malloc
+#define xrealloc    realloc
+#define xcalloc     calloc
+#define xfree       free
+
 #ifdef C_ALLOCA
 #define FREE_VARIABLES() alloca(0)
 #else
@@ -127,10 +139,12 @@
   unsigned int xlen = stacke - stackb; 					\
   if (stackb == stacka) {						\
     stackx = (type*)xmalloc(2 * xlen * sizeof(type));			\
+    if (!stackx) goto memory_exhausted;					\
     memcpy(stackx, stackb, xlen * sizeof (type));			\
   }									\
   else {								\
     stackx = (type*)xrealloc(stackb, 2 * xlen * sizeof(type));		\
+    if (!stackx) goto memory_exhausted;					\
   }									\
   /* Rearrange the pointers. */						\
   stackp = stackx + (stackp - stackb);					\
@@ -2769,8 +2783,8 @@
    The caller must supply the address of a (1 << BYTEWIDTH)-byte data 
    area as bufp->fastmap.
    The other components of bufp describe the pattern to be used.  */
-void
-re_compile_fastmap(bufp)
+static int
+re_compile_fastmap0(bufp)
      struct re_pattern_buffer *bufp;
 {
   unsigned char *pattern = (unsigned char*)bufp->buffer;
@@ -2938,7 +2952,7 @@
 	    fastmap[j] = 1;
 	}
 	if (bufp->can_be_null) {
-	  FREE_AND_RETURN_VOID(stackb);
+	  FREE_AND_RETURN(stackb, 0);
 	}
 	/* Don't return; check the alternative paths
 	   so we can set can_be_null if appropriate.  */
@@ -3104,7 +3118,16 @@
     else
       break;
   }
-  FREE_AND_RETURN_VOID(stackb);
+  FREE_AND_RETURN(stackb, 0);
+ memory_exhausted:
+  FREE_AND_RETURN(stackb, -2);
+}
+
+void
+re_compile_fastmap(bufp)
+     struct re_pattern_buffer *bufp;
+{
+  (void)re_compile_fastmap0(bufp);
 }
 
 /* adjust startpos value to the position between characters. */
@@ -3116,7 +3139,8 @@
 {
   /* Update the fastmap now if not correct already.  */
   if (!bufp->fastmap_accurate) {
-    re_compile_fastmap(bufp);
+    int ret = re_compile_fastmap0(bufp);
+    if (ret) return ret;
   }
 
   /* Adjust startpos for mbc string */
@@ -3171,7 +3195,8 @@
 
   /* Update the fastmap now if not correct already.  */
   if (fastmap && !bufp->fastmap_accurate) {
-    re_compile_fastmap(bufp);
+    int ret = re_compile_fastmap0(bufp);
+    if (ret) return ret;
   }
 
 
@@ -3561,7 +3586,7 @@
      ``dummy''; if a failure happens and the failure point is a dummy, it
      gets discarded and the next next one is tried.  */
 
-  unsigned char **stacka;
+  unsigned char **const stacka = 0;
   unsigned char **stackb;
   unsigned char **stackp;
   unsigned char **stacke;
@@ -3610,8 +3635,7 @@
   }
 
   /* Initialize the stack. */
-  stacka = RE_TALLOC(MAX_NUM_FAILURE_ITEMS * NFAILURES, unsigned char*);
-  stackb = stacka;
+  stackb = TMALLOC(MAX_NUM_FAILURE_ITEMS * NFAILURES, unsigned char*);
   stackp = stackb;
   stacke = &stackb[MAX_NUM_FAILURE_ITEMS * NFAILURES];
 
@@ -4381,6 +4405,8 @@
     goto restore_best_regs;
 
   FREE_AND_RETURN(stackb,(-1)); 	/* Failure to match.  */
+ memory_exhausted:
+  FREE_AND_RETURN(stackb,(-2));
 }
 
 
@@ -4644,5 +4670,5 @@
   mode		 : C
   c-file-style	 : "gnu"
   tab-width	 : 8
-  End		 :
+  End
 */
